<PATH_START> (0,0) (1,0) (2,0) (3,0) (3,1) (3,2) (3,3) <PATH_END>

This problem can be solved through DFS(Depth First Search) algorithm. We start in the origin cell and check if adjacent cells are either the exit cell or have not been visted yet. Once we find the adjacent cell that satisfy our condition, we check for the adjacent cells of these cells until a path to our target cell gets formed. In case, if no exit cell is found and all of the adjacent cells of current cell have been visited, we will backtrack to check other adjacent cell of it's parent cell that has not been visited to find a proper path.

Path does not cross any walls: In the maze, path can only cross from adjacent cells. To go from any cell to its adjacent cell it will only have the option to go up, down,left or right. This is only possible through edges which represent existence paths between two adjacent cell in this adjacency list format of our maze. Therefore all the movements and path formed to go into adjacent direction will only be through valid edges.

Path uses only adjacent cells: Path was generated by checking whether the adjacent cell of our current position was visited by searching its presence if any of our path's cells, if found then we skip that cell, else if not found we go to that cell and add in our path. In this way, every cell in our path is always adjacent of it previous path's cell.